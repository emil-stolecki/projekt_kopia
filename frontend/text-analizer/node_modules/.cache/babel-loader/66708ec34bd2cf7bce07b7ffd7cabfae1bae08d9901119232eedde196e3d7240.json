{"ast":null,"code":"\"use strict\";\n\nvar ShortUniqueId = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n  var __export = (target, all) => {\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n        get: () => from[key],\n        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n      });\n    }\n    return to;\n  };\n  var __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n    value: true\n  }), mod);\n  var __publicField = (obj, key, value) => {\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n  };\n\n  // src/index.ts\n  var src_exports = {};\n  __export(src_exports, {\n    DEFAULT_OPTIONS: () => DEFAULT_OPTIONS,\n    DEFAULT_UUID_LENGTH: () => DEFAULT_UUID_LENGTH,\n    default: () => ShortUniqueId\n  });\n\n  // package.json\n  var version = \"5.0.3\";\n\n  // src/index.ts\n  var DEFAULT_UUID_LENGTH = 6;\n  var DEFAULT_OPTIONS = {\n    dictionary: \"alphanum\",\n    shuffle: true,\n    debug: false,\n    length: DEFAULT_UUID_LENGTH,\n    counter: 0\n  };\n  var _ShortUniqueId = class _ShortUniqueId {\n    constructor(argOptions = {}) {\n      __publicField(this, \"counter\");\n      __publicField(this, \"debug\");\n      __publicField(this, \"dict\");\n      __publicField(this, \"version\");\n      __publicField(this, \"dictIndex\", 0);\n      __publicField(this, \"dictRange\", []);\n      __publicField(this, \"lowerBound\", 0);\n      __publicField(this, \"upperBound\", 0);\n      __publicField(this, \"dictLength\", 0);\n      __publicField(this, \"uuidLength\");\n      __publicField(this, \"_digit_first_ascii\", 48);\n      __publicField(this, \"_digit_last_ascii\", 58);\n      __publicField(this, \"_alpha_lower_first_ascii\", 97);\n      __publicField(this, \"_alpha_lower_last_ascii\", 123);\n      __publicField(this, \"_hex_last_ascii\", 103);\n      __publicField(this, \"_alpha_upper_first_ascii\", 65);\n      __publicField(this, \"_alpha_upper_last_ascii\", 91);\n      __publicField(this, \"_number_dict_ranges\", {\n        digits: [this._digit_first_ascii, this._digit_last_ascii]\n      });\n      __publicField(this, \"_alpha_dict_ranges\", {\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      });\n      __publicField(this, \"_alpha_lower_dict_ranges\", {\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]\n      });\n      __publicField(this, \"_alpha_upper_dict_ranges\", {\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      });\n      __publicField(this, \"_alphanum_dict_ranges\", {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      });\n      __publicField(this, \"_alphanum_lower_dict_ranges\", {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]\n      });\n      __publicField(this, \"_alphanum_upper_dict_ranges\", {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      });\n      __publicField(this, \"_hex_dict_ranges\", {\n        decDigits: [this._digit_first_ascii, this._digit_last_ascii],\n        alphaDigits: [this._alpha_lower_first_ascii, this._hex_last_ascii]\n      });\n      __publicField(this, \"_dict_ranges\", {\n        _number_dict_ranges: this._number_dict_ranges,\n        _alpha_dict_ranges: this._alpha_dict_ranges,\n        _alpha_lower_dict_ranges: this._alpha_lower_dict_ranges,\n        _alpha_upper_dict_ranges: this._alpha_upper_dict_ranges,\n        _alphanum_dict_ranges: this._alphanum_dict_ranges,\n        _alphanum_lower_dict_ranges: this._alphanum_lower_dict_ranges,\n        _alphanum_upper_dict_ranges: this._alphanum_upper_dict_ranges,\n        _hex_dict_ranges: this._hex_dict_ranges\n      });\n      /* tslint:disable consistent-return */\n      __publicField(this, \"log\", (...args) => {\n        const finalArgs = [...args];\n        finalArgs[0] = `[short-unique-id] ${args[0]}`;\n        if (this.debug === true) {\n          if (typeof console !== \"undefined\" && console !== null) {\n            return console.log(...finalArgs);\n          }\n        }\n      });\n      /* tslint:enable consistent-return */\n      /** Change the dictionary after initialization. */\n      __publicField(this, \"setDictionary\", (dictionary, shuffle) => {\n        let finalDict;\n        if (dictionary && Array.isArray(dictionary) && dictionary.length > 1) {\n          finalDict = dictionary;\n        } else {\n          finalDict = [];\n          let i;\n          this.dictIndex = i = 0;\n          const rangesName = `_${dictionary}_dict_ranges`;\n          const ranges = this._dict_ranges[rangesName];\n          Object.keys(ranges).forEach(rangeType => {\n            const rangeTypeKey = rangeType;\n            this.dictRange = ranges[rangeTypeKey];\n            this.lowerBound = this.dictRange[0];\n            this.upperBound = this.dictRange[1];\n            for (this.dictIndex = i = this.lowerBound; this.lowerBound <= this.upperBound ? i < this.upperBound : i > this.upperBound; this.dictIndex = this.lowerBound <= this.upperBound ? i += 1 : i -= 1) {\n              finalDict.push(String.fromCharCode(this.dictIndex));\n            }\n          });\n        }\n        if (shuffle) {\n          const PROBABILITY = 0.5;\n          finalDict = finalDict.sort(() => Math.random() - PROBABILITY);\n        }\n        this.dict = finalDict;\n        this.dictLength = this.dict.length;\n        this.setCounter(0);\n      });\n      __publicField(this, \"seq\", () => {\n        return this.sequentialUUID();\n      });\n      /**\n       * Generates UUID based on internal counter that's incremented after each ID generation.\n       * @alias `const uid = new ShortUniqueId(); uid.seq();`\n       */\n      __publicField(this, \"sequentialUUID\", () => {\n        let counterDiv;\n        let counterRem;\n        let id = \"\";\n        counterDiv = this.counter;\n        do {\n          counterRem = counterDiv % this.dictLength;\n          counterDiv = Math.trunc(counterDiv / this.dictLength);\n          id += this.dict[counterRem];\n        } while (counterDiv !== 0);\n        this.counter += 1;\n        return id;\n      });\n      __publicField(this, \"rnd\", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {\n        return this.randomUUID(uuidLength);\n      });\n      /**\n       * Generates UUID by creating each part randomly.\n       * @alias `const uid = new ShortUniqueId(); uid.rnd(uuidLength: number);`\n       */\n      __publicField(this, \"randomUUID\", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {\n        let id;\n        let randomPartIdx;\n        let j;\n        if (uuidLength === null || typeof uuidLength === \"undefined\" || uuidLength < 1) {\n          throw new Error(\"Invalid UUID Length Provided\");\n        }\n        const isPositive = uuidLength >= 0;\n        id = \"\";\n        for (j = 0; j < uuidLength; j += 1) {\n          randomPartIdx = parseInt((Math.random() * this.dictLength).toFixed(0), 10) % this.dictLength;\n          id += this.dict[randomPartIdx];\n        }\n        return id;\n      });\n      __publicField(this, \"fmt\", (format, date) => {\n        return this.formattedUUID(format, date);\n      });\n      /**\n       * Generates custom UUID with the provided format string.\n       * @alias `const uid = new ShortUniqueId(); uid.fmt(format: string);`\n       */\n      __publicField(this, \"formattedUUID\", (format, date) => {\n        const fnMap = {\n          \"$r\": this.randomUUID,\n          \"$s\": this.sequentialUUID,\n          \"$t\": this.stamp\n        };\n        const result = format.replace(/\\$[rs]\\d{0,}|\\$t0|\\$t[1-9]\\d{1,}/g, m => {\n          const fn = m.slice(0, 2);\n          const len = parseInt(m.slice(2), 10);\n          if (fn === \"$s\") {\n            return fnMap[fn]().padStart(len, \"0\");\n          }\n          if (fn === \"$t\" && date) {\n            return fnMap[fn](len, date);\n          }\n          return fnMap[fn](len);\n        });\n        return result;\n      });\n      /**\n       * Calculates total number of possible UUIDs.\n       *\n       * Given that:\n       *\n       * - `H` is the total number of possible UUIDs\n       * - `n` is the number of unique characters in the dictionary\n       * - `l` is the UUID length\n       *\n       * Then `H` is defined as `n` to the power of `l`:\n       *\n       * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n       *  <img src=\"https://render.githubusercontent.com/render/math?math=%5CHuge%20H=n%5El\"/>\n       * </div>\n       *\n       * This function returns `H`.\n       */\n      __publicField(this, \"availableUUIDs\", (uuidLength = this.uuidLength) => {\n        return parseFloat(Math.pow([...new Set(this.dict)].length, uuidLength).toFixed(0));\n      });\n      /**\n       * Calculates approximate number of hashes before first collision.\n       *\n       * Given that:\n       *\n       * - `H` is the total number of possible UUIDs, or in terms of this library,\n       * the result of running `availableUUIDs()`\n       * - the expected number of values we have to choose before finding the\n       * first collision can be expressed as the quantity `Q(H)`\n       *\n       * Then `Q(H)` can be approximated as the square root of the product of half\n       * of pi times `H`:\n       *\n       * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n       *  <img src=\"https://render.githubusercontent.com/render/math?math=%5CHuge%20Q(H)%5Capprox%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7DH%7D\"/>\n       * </div>\n       *\n       * This function returns `Q(H)`.\n       * \n       * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n       */\n      __publicField(this, \"approxMaxBeforeCollision\", (rounds = this.availableUUIDs(this.uuidLength)) => {\n        return parseFloat(Math.sqrt(Math.PI / 2 * rounds).toFixed(20));\n      });\n      /**\n       * Calculates probability of generating duplicate UUIDs (a collision) in a\n       * given number of UUID generation rounds.\n       *\n       * Given that:\n       *\n       * - `r` is the maximum number of times that `randomUUID()` will be called,\n       * or better said the number of _rounds_\n       * - `H` is the total number of possible UUIDs, or in terms of this library,\n       * the result of running `availableUUIDs()`\n       *\n       * Then the probability of collision `p(r; H)` can be approximated as the result\n       * of dividing the square root of the product of half of pi times `r` by `H`:\n       *\n       * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n       *  <img src=\"https://render.githubusercontent.com/render/math?math=%5CHuge%20p(r%3B%20H)%5Capprox%5Cfrac%7B%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7Dr%7D%7D%7BH%7D\"/>\n       * </div>\n       *\n       * This function returns `p(r; H)`.\n       * \n       * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n       *\n       * (Useful if you are wondering _\"If I use this lib and expect to perform at most\n       * `r` rounds of UUID generations, what is the probability that I will hit a duplicate UUID?\"_.)\n       */\n      __publicField(this, \"collisionProbability\", (rounds = this.availableUUIDs(this.uuidLength), uuidLength = this.uuidLength) => {\n        return parseFloat((this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)).toFixed(20));\n      });\n      /**\n       * Calculate a \"uniqueness\" score (from 0 to 1) of UUIDs based on size of\n       * dictionary and chosen UUID length.\n       *\n       * Given that:\n       *\n       * - `H` is the total number of possible UUIDs, or in terms of this library,\n       * the result of running `availableUUIDs()`\n       * - `Q(H)` is the approximate number of hashes before first collision,\n       * or in terms of this library, the result of running `approxMaxBeforeCollision()`\n       *\n       * Then `uniqueness` can be expressed as the additive inverse of the probability of\n       * generating a \"word\" I had previously generated (a duplicate) at any given iteration\n       * up to the the total number of possible UUIDs expressed as the quotiend of `Q(H)` and `H`:\n       *\n       * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n       *  <img src=\"https://render.githubusercontent.com/render/math?math=%5CHuge%201-%5Cfrac%7BQ(H)%7D%7BH%7D\"/>\n       * </div>\n       *\n       * (Useful if you need a value to rate the \"quality\" of the combination of given dictionary\n       * and UUID length. The closer to 1, higher the uniqueness and thus better the quality.)\n       */\n      __publicField(this, \"uniqueness\", (rounds = this.availableUUIDs(this.uuidLength)) => {\n        const score = parseFloat((1 - this.approxMaxBeforeCollision(rounds) / rounds).toFixed(20));\n        return score > 1 ? 1 : score < 0 ? 0 : score;\n      });\n      /**\n       * Return the version of this module.\n       */\n      __publicField(this, \"getVersion\", () => {\n        return this.version;\n      });\n      /**\n       * Generates a UUID with a timestamp that can be extracted using `uid.parseStamp(stampString);`.\n       * \n       * ```js\n       *  const uidWithTimestamp = uid.stamp(32);\n       *  console.log(uidWithTimestamp);\n       *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n       * \n       *  console.log(uid.parseStamp(uidWithTimestamp));\n       *  // 2021-05-03T06:24:58.000Z\n       *  ```\n       */\n      __publicField(this, \"stamp\", (finalLength, date) => {\n        const hexStamp = Math.floor(+(date || /* @__PURE__ */new Date()) / 1e3).toString(16);\n        if (typeof finalLength === \"number\" && finalLength === 0) {\n          return hexStamp;\n        }\n        if (typeof finalLength !== \"number\" || finalLength < 10) {\n          throw new Error([\"Param finalLength must be a number greater than or equal to 10,\", \"or 0 if you want the raw hexadecimal timestamp\"].join(\"\\n\"));\n        }\n        const idLength = finalLength - 9;\n        const rndIdx = Math.round(Math.random() * (idLength > 15 ? 15 : idLength));\n        const id = this.randomUUID(idLength);\n        return `${id.substring(0, rndIdx)}${hexStamp}${id.substring(rndIdx)}${rndIdx.toString(16)}`;\n      });\n      /**\n       * Extracts the date embeded in a UUID generated using the `uid.stamp(finalLength);` method.\n       * \n       * ```js\n       *  const uidWithTimestamp = uid.stamp(32);\n       *  console.log(uidWithTimestamp);\n       *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n       * \n       *  console.log(uid.parseStamp(uidWithTimestamp));\n       *  // 2021-05-03T06:24:58.000Z\n       *  ```\n       */\n      __publicField(this, \"parseStamp\", (suid, format) => {\n        if (format && !/t0|t[1-9]\\d{1,}/.test(format)) {\n          throw new Error(\"Cannot extract date from a formated UUID with no timestamp in the format\");\n        }\n        const stamp = format ? format.replace(/\\$[rs]\\d{0,}|\\$t0|\\$t[1-9]\\d{1,}/g, m => {\n          const fnMap = {\n            \"$r\": len2 => [...Array(len2)].map(() => \"r\").join(\"\"),\n            \"$s\": len2 => [...Array(len2)].map(() => \"s\").join(\"\"),\n            \"$t\": len2 => [...Array(len2)].map(() => \"t\").join(\"\")\n          };\n          const fn = m.slice(0, 2);\n          const len = parseInt(m.slice(2), 10);\n          return fnMap[fn](len);\n        }).replace(/^(.*?)(t{8,})(.*)$/g, (_m, p1, p2) => {\n          return suid.substring(p1.length, p1.length + p2.length);\n        }) : suid;\n        if (stamp.length === 8) {\n          return new Date(parseInt(stamp, 16) * 1e3);\n        }\n        if (stamp.length < 10) {\n          throw new Error(\"Stamp length invalid\");\n        }\n        const rndIdx = parseInt(stamp.substring(stamp.length - 1), 16);\n        return new Date(parseInt(stamp.substring(rndIdx, rndIdx + 8), 16) * 1e3);\n      });\n      /**\n       * Set the counter to a specific value.\n       */\n      __publicField(this, \"setCounter\", counter => {\n        this.counter = counter;\n      });\n      const options = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), argOptions);\n      this.counter = 0;\n      this.debug = false;\n      this.dict = [];\n      this.version = version;\n      const {\n        dictionary,\n        shuffle,\n        length,\n        counter\n      } = options;\n      this.uuidLength = length;\n      this.setDictionary(dictionary, shuffle);\n      this.setCounter(counter);\n      this.debug = options.debug;\n      this.log(this.dict);\n      this.log(`Generator instantiated with Dictionary Size ${this.dictLength} and counter set to ${this.counter}`);\n      this.log = this.log.bind(this);\n      this.setDictionary = this.setDictionary.bind(this);\n      this.setCounter = this.setCounter.bind(this);\n      this.seq = this.seq.bind(this);\n      this.sequentialUUID = this.sequentialUUID.bind(this);\n      this.rnd = this.rnd.bind(this);\n      this.randomUUID = this.randomUUID.bind(this);\n      this.fmt = this.fmt.bind(this);\n      this.formattedUUID = this.formattedUUID.bind(this);\n      this.availableUUIDs = this.availableUUIDs.bind(this);\n      this.approxMaxBeforeCollision = this.approxMaxBeforeCollision.bind(this);\n      this.collisionProbability = this.collisionProbability.bind(this);\n      this.uniqueness = this.uniqueness.bind(this);\n      this.getVersion = this.getVersion.bind(this);\n      this.stamp = this.stamp.bind(this);\n      this.parseStamp = this.parseStamp.bind(this);\n      return this;\n    }\n  };\n  /** @hidden */\n  __publicField(_ShortUniqueId, \"default\", _ShortUniqueId);\n  var ShortUniqueId = _ShortUniqueId;\n  return __toCommonJS(src_exports);\n})();\n'undefined' != typeof module && (module.exports = ShortUniqueId.default), 'undefined' != typeof window && (ShortUniqueId = ShortUniqueId.default);","map":{"version":3,"names":["src_exports","__export","DEFAULT_OPTIONS","DEFAULT_UUID_LENGTH","default","ShortUniqueId","version","dictionary","shuffle","debug","length","counter","_ShortUniqueId","constructor","argOptions","__publicField","digits","_digit_first_ascii","_digit_last_ascii","lowerCase","_alpha_lower_first_ascii","_alpha_lower_last_ascii","upperCase","_alpha_upper_first_ascii","_alpha_upper_last_ascii","decDigits","alphaDigits","_hex_last_ascii","_number_dict_ranges","_alpha_dict_ranges","_alpha_lower_dict_ranges","_alpha_upper_dict_ranges","_alphanum_dict_ranges","_alphanum_lower_dict_ranges","_alphanum_upper_dict_ranges","_hex_dict_ranges","args","finalArgs","console","log","finalDict","Array","isArray","i","dictIndex","rangesName","ranges","_dict_ranges","Object","keys","forEach","rangeType","rangeTypeKey","dictRange","lowerBound","upperBound","push","String","fromCharCode","PROBABILITY","sort","Math","random","dict","dictLength","setCounter","sequentialUUID","counterDiv","counterRem","id","trunc","uuidLength","randomUUID","randomPartIdx","j","Error","isPositive","parseInt","toFixed","format","date","formattedUUID","fnMap","stamp","result","replace","m","fn","slice","len","padStart","parseFloat","pow","Set","rounds","availableUUIDs","sqrt","PI","approxMaxBeforeCollision","score","finalLength","hexStamp","floor","Date","toString","join","idLength","rndIdx","round","substring","suid","test","len2","map","_m","p1","p2","options","__spreadValues","setDictionary","bind","seq","rnd","fmt","collisionProbability","uniqueness","getVersion","parseStamp"],"sources":["/home/emil/github/projektDyplomowy/projekt_kopia/frontend/text-analizer/node_modules/short-unique-id/src/index.ts","/home/emil/github/projektDyplomowy/projekt_kopia/frontend/text-analizer/node_modules/short-unique-id/package.json"],"sourcesContent":["/**\n * @packageDocumentation\n **/\n\n// Copyright 2017-2022 the Short Unique ID authors. All rights reserved. Apache 2.0 license.\n\n// @ts-ignore\nimport {version} from '../package.json';\n\nexport interface ShortUniqueIdRanges {\n  [k: string]: [number, number];\n};\n\nexport interface ShortUniqueIdRangesMap {\n  [k: string]: ShortUniqueIdRanges;\n};\n\nexport type ShortUniqueIdDefaultDictionaries = 'number' | 'alpha' | 'alpha_lower' | 'alpha_upper' | 'alphanum' | 'alphanum_lower' | 'alphanum_upper' | 'hex';\n\n/**\n * ```js\n * {\n *   dictionary: ['z', 'a', 'p', 'h', 'o', 'd', ...],\n *   shuffle: false,\n *   debug: false,\n *   length: 6,\n * }\n * ```\n * <br/>\n * @see {@link DEFAULT_OPTIONS}\n */\nexport interface ShortUniqueIdOptions {\n  /** User-defined character dictionary */\n  dictionary: string[] | ShortUniqueIdDefaultDictionaries;\n\n  /** If true, sequentialUUID use the dictionary in the given order */\n  shuffle: boolean;\n\n  /** If true the instance will console.log useful info */\n  debug: boolean;\n\n  /** From 1 to infinity, the length you wish your UUID to be */\n  length: number;\n\n  /** From 0 to infinity, the current value for the sequential UUID counter */\n  counter: number;\n};\n\n/**\n * 6 was chosen as the default UUID length since for most cases\n * it will be more than aptly suitable to provide millions of UUIDs\n * with a very low probability of producing a duplicate UUID.\n *\n * For example, with a dictionary including digits from 0 to 9,\n * as well as the alphabet from a to z both in UPPER and lower case,\n * the probability of generating a duplicate in 1,000,000 rounds\n * is ~0.00000002, or about 1 in 50,000,000.\n */\nexport const DEFAULT_UUID_LENGTH: number = 6;\n\nexport const DEFAULT_OPTIONS: ShortUniqueIdOptions = {\n  dictionary: 'alphanum',\n  shuffle: true,\n  debug: false,\n  length: DEFAULT_UUID_LENGTH,\n  counter: 0,\n};\n\n/**\n * Generate random or sequential UUID of any length.\n *\n * ### Use as module\n *\n * ```js\n * // Deno (web module) Import\n * import ShortUniqueId from 'https://cdn.jsdelivr.net/npm/short-unique-id@latest/src/index.ts';\n *\n * // ES6 / TypeScript Import\n * import ShortUniqueId from 'short-unique-id';\n *\n * // or Node.js require\n * const ShortUniqueId = require('short-unique-id');\n *\n * // Instantiate\n * const uid = new ShortUniqueId();\n *\n * // Random UUID\n * console.log(uid.rnd());\n *\n * // Sequential UUID\n * console.log(uid.seq());\n * ```\n *\n * ### Use in browser\n *\n * ```html\n * <!-- Import -->\n * <script src=\"https://cdn.jsdelivr.net/npm/short-unique-id@latest/dist/short-unique-id.min.js\"></script>\n *\n * <!-- Usage -->\n * <script>\n *   // Instantiate\n *   var uid = new ShortUniqueId();\n *\n *   // Random UUID\n *   document.write(uid.rnd());\n *\n *   // Sequential UUID\n *   document.write(uid.seq());\n * </script>\n * ```\n *\n * ### Options\n *\n * Options can be passed when instantiating `uid`:\n *\n * ```js\n * const options = { ... };\n *\n * const uid = new ShortUniqueId(options);\n * ```\n *\n * For more information take a look at the [ShortUniqueIdOptions type definition](/interfaces/shortuniqueidoptions.html).\n */\nexport default class ShortUniqueId {\n  /** @hidden */\n  static default: typeof ShortUniqueId = ShortUniqueId;\n\n  public counter: number;\n  public debug: boolean;\n  public dict: string[];\n  public version: string;\n  public dictIndex: number = 0;\n  public dictRange: number[] =[];\n  public lowerBound: number = 0;\n  public upperBound: number = 0;\n  public dictLength: number = 0;\n  public uuidLength: number;\n\n  protected _digit_first_ascii: number = 48;\n  protected _digit_last_ascii: number = 58;\n  protected _alpha_lower_first_ascii: number = 97;\n  protected _alpha_lower_last_ascii: number = 123;\n  protected _hex_last_ascii: number = 103;\n  protected _alpha_upper_first_ascii: number = 65;\n  protected _alpha_upper_last_ascii: number = 91;\n\n  protected _number_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n  };\n\n  protected _alpha_dict_ranges: ShortUniqueIdRanges = {\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alpha_lower_dict_ranges: ShortUniqueIdRanges = {\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n  };\n\n  protected _alpha_upper_dict_ranges: ShortUniqueIdRanges = {\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alphanum_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _alphanum_lower_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n  };\n\n  protected _alphanum_upper_dict_ranges: ShortUniqueIdRanges = {\n    digits: [this._digit_first_ascii, this._digit_last_ascii],\n    upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii],\n  };\n\n  protected _hex_dict_ranges: ShortUniqueIdRanges = {\n    decDigits: [this._digit_first_ascii, this._digit_last_ascii],\n    alphaDigits: [this._alpha_lower_first_ascii, this._hex_last_ascii],\n  };\n\n  protected _dict_ranges: ShortUniqueIdRangesMap = {\n    _number_dict_ranges: this._number_dict_ranges,\n    _alpha_dict_ranges: this._alpha_dict_ranges,\n    _alpha_lower_dict_ranges: this._alpha_lower_dict_ranges,\n    _alpha_upper_dict_ranges: this._alpha_upper_dict_ranges,\n    _alphanum_dict_ranges: this._alphanum_dict_ranges,\n    _alphanum_lower_dict_ranges: this._alphanum_lower_dict_ranges,\n    _alphanum_upper_dict_ranges: this._alphanum_upper_dict_ranges,\n    _hex_dict_ranges: this._hex_dict_ranges,\n  };\n\n  /* tslint:disable consistent-return */\n  protected log = (...args: any[]): void => {\n    const finalArgs = [...args];\n    finalArgs[0] = `[short-unique-id] ${args[0]}`;\n    /* tslint:disable no-console */\n    if (this.debug === true) {\n      if (typeof console !== 'undefined' && console !== null) {\n        return console.log(...finalArgs);\n      }\n    }\n    /* tslint:enable no-console */\n  };\n  /* tslint:enable consistent-return */\n\n  /** Change the dictionary after initialization. */\n  setDictionary = (dictionary: string[] | ShortUniqueIdDefaultDictionaries, shuffle?: boolean): void => {\n    let finalDict: string[];\n\n    if (dictionary && Array.isArray(dictionary) && dictionary.length > 1) {\n      finalDict = dictionary as string[];\n    } else {\n      finalDict = [];\n\n      let i;\n\n      this.dictIndex = i = 0;\n\n      const rangesName = `_${dictionary as ShortUniqueIdDefaultDictionaries}_dict_ranges`;\n      const ranges = this._dict_ranges[rangesName];\n\n      Object.keys(ranges).forEach((rangeType) => {\n        const rangeTypeKey = rangeType;\n\n        this.dictRange = ranges[rangeTypeKey];\n\n        this.lowerBound = this.dictRange[0];\n        this.upperBound = this.dictRange[1];\n\n        for (\n          this.dictIndex = i = this.lowerBound;\n          this.lowerBound <= this.upperBound ? i < this.upperBound : i > this.upperBound;\n          this.dictIndex = this.lowerBound <= this.upperBound ? i += 1 : i -= 1\n        ) {\n          finalDict.push(String.fromCharCode(this.dictIndex));\n        }\n      });\n    }\n\n    if (shuffle) {\n      // Shuffle Dictionary to remove selection bias.\n      const PROBABILITY = 0.5;\n      finalDict = finalDict.sort(() => Math.random() - PROBABILITY);\n    }\n\n    this.dict = finalDict;\n\n    // Cache Dictionary Length for future usage.\n    this.dictLength = this.dict.length;\n\n    // Reset internal counter.\n    this.setCounter(0);\n  };\n\n  seq = (): string => {\n    return this.sequentialUUID();\n  };\n\n  /**\n   * Generates UUID based on internal counter that's incremented after each ID generation.\n   * @alias `const uid = new ShortUniqueId(); uid.seq();`\n   */\n  sequentialUUID = (): string => {\n    let counterDiv: number;\n    let counterRem: number;\n    let id: string = '';\n\n    counterDiv = this.counter;\n\n    do {\n      counterRem = counterDiv % this.dictLength;\n      counterDiv = Math.trunc(counterDiv / this.dictLength);\n      id += this.dict[counterRem];\n    } while (counterDiv !== 0);\n\n    this.counter += 1;\n\n    return id;\n  };\n\n  rnd = (uuidLength: number = this.uuidLength || DEFAULT_UUID_LENGTH): string => {\n    return this.randomUUID(uuidLength);\n  };\n\n  /**\n   * Generates UUID by creating each part randomly.\n   * @alias `const uid = new ShortUniqueId(); uid.rnd(uuidLength: number);`\n   */\n  randomUUID = (uuidLength: number = this.uuidLength || DEFAULT_UUID_LENGTH): string => {\n    let id: string;\n    let randomPartIdx: number;\n    let j: number;\n\n    if ((uuidLength === null || typeof uuidLength === 'undefined') || uuidLength < 1) {\n      throw new Error('Invalid UUID Length Provided');\n    }\n\n    const isPositive = uuidLength >= 0;\n\n    // Generate random ID parts from Dictionary.\n    id = '';\n    for (\n      j = 0;\n      j < uuidLength;\n      j += 1\n    ) {\n      randomPartIdx = parseInt(\n        (Math.random() * this.dictLength).toFixed(0),\n        10,\n      ) % this.dictLength;\n      id += this.dict[randomPartIdx];\n    }\n\n    // Return random generated ID.\n    return id;\n  };\n\n  fmt = (format: string, date?: Date): string => {\n    return this.formattedUUID(format, date);\n  };\n\n  /**\n   * Generates custom UUID with the provided format string.\n   * @alias `const uid = new ShortUniqueId(); uid.fmt(format: string);`\n   */\n  formattedUUID = (format: string, date?: Date): string => {\n    const fnMap = {\n      '$r': this.randomUUID,\n      '$s': this.sequentialUUID,\n      '$t': this.stamp,\n    };\n\n    const result = format.replace(\n      /\\$[rs]\\d{0,}|\\$t0|\\$t[1-9]\\d{1,}/g,\n      (m) => {\n        const fn = m.slice(0, 2);\n        const len = parseInt(m.slice(2), 10);\n\n        if (fn === '$s') {\n          return fnMap[fn]().padStart(len, '0');\n        }\n\n        if (fn === '$t' && date) {\n          return fnMap[fn](len, date);\n        }\n\n        return fnMap[fn as keyof typeof fnMap](len);\n      },\n    );\n\n    return result;\n  };\n\n  /**\n   * Calculates total number of possible UUIDs.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs\n   * - `n` is the number of unique characters in the dictionary\n   * - `l` is the UUID length\n   *\n   * Then `H` is defined as `n` to the power of `l`:\n   *\n   * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n   *  <img src=\"https://render.githubusercontent.com/render/math?math=%5CHuge%20H=n%5El\"/>\n   * </div>\n   *\n   * This function returns `H`.\n   */\n  availableUUIDs = (uuidLength: number = this.uuidLength): number => {\n    return parseFloat(\n      Math.pow([...new Set(this.dict)].length, uuidLength).toFixed(0),\n    );\n  };\n\n  /**\n   * Calculates approximate number of hashes before first collision.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   * - the expected number of values we have to choose before finding the\n   * first collision can be expressed as the quantity `Q(H)`\n   *\n   * Then `Q(H)` can be approximated as the square root of the product of half\n   * of pi times `H`:\n   *\n   * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n   *  <img src=\"https://render.githubusercontent.com/render/math?math=%5CHuge%20Q(H)%5Capprox%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7DH%7D\"/>\n   * </div>\n   *\n   * This function returns `Q(H)`.\n   * \n   * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n   */\n  approxMaxBeforeCollision = (rounds: number = this.availableUUIDs(this.uuidLength)): number => {\n    return parseFloat(\n      Math.sqrt((Math.PI / 2) * rounds).toFixed(20),\n    );\n  };\n\n  /**\n   * Calculates probability of generating duplicate UUIDs (a collision) in a\n   * given number of UUID generation rounds.\n   *\n   * Given that:\n   *\n   * - `r` is the maximum number of times that `randomUUID()` will be called,\n   * or better said the number of _rounds_\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   *\n   * Then the probability of collision `p(r; H)` can be approximated as the result\n   * of dividing the square root of the product of half of pi times `r` by `H`:\n   *\n   * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n   *  <img src=\"https://render.githubusercontent.com/render/math?math=%5CHuge%20p(r%3B%20H)%5Capprox%5Cfrac%7B%5Csqrt%7B%5Cfrac%7B%5Cpi%7D%7B2%7Dr%7D%7D%7BH%7D\"/>\n   * </div>\n   *\n   * This function returns `p(r; H)`.\n   * \n   * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n   *\n   * (Useful if you are wondering _\"If I use this lib and expect to perform at most\n   * `r` rounds of UUID generations, what is the probability that I will hit a duplicate UUID?\"_.)\n   */\n  collisionProbability = (\n    rounds: number = this.availableUUIDs(this.uuidLength),\n    uuidLength: number = this.uuidLength,\n  ): number => {\n    return parseFloat(\n      (\n        this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)\n      ).toFixed(20),\n    );\n  };\n\n  /**\n   * Calculate a \"uniqueness\" score (from 0 to 1) of UUIDs based on size of\n   * dictionary and chosen UUID length.\n   *\n   * Given that:\n   *\n   * - `H` is the total number of possible UUIDs, or in terms of this library,\n   * the result of running `availableUUIDs()`\n   * - `Q(H)` is the approximate number of hashes before first collision,\n   * or in terms of this library, the result of running `approxMaxBeforeCollision()`\n   *\n   * Then `uniqueness` can be expressed as the additive inverse of the probability of\n   * generating a \"word\" I had previously generated (a duplicate) at any given iteration\n   * up to the the total number of possible UUIDs expressed as the quotiend of `Q(H)` and `H`:\n   *\n   * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n   *  <img src=\"https://render.githubusercontent.com/render/math?math=%5CHuge%201-%5Cfrac%7BQ(H)%7D%7BH%7D\"/>\n   * </div>\n   *\n   * (Useful if you need a value to rate the \"quality\" of the combination of given dictionary\n   * and UUID length. The closer to 1, higher the uniqueness and thus better the quality.)\n   */\n  uniqueness = (rounds: number = this.availableUUIDs(this.uuidLength)): number => {\n    const score = parseFloat(\n      (1 - (\n        this.approxMaxBeforeCollision(rounds) / rounds\n      )).toFixed(20),\n    );\n    return (\n      score > 1\n    ) ? (\n      1\n    ) : (\n      (score < 0) ? 0 : score\n    );\n  };\n\n  /**\n   * Return the version of this module.\n   */\n  getVersion = (): string => {\n    return this.version;\n  };\n\n  /**\n   * Generates a UUID with a timestamp that can be extracted using `uid.parseStamp(stampString);`.\n   * \n   * ```js\n   *  const uidWithTimestamp = uid.stamp(32);\n   *  console.log(uidWithTimestamp);\n   *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n   * \n   *  console.log(uid.parseStamp(uidWithTimestamp));\n   *  // 2021-05-03T06:24:58.000Z\n   *  ```\n   */\n  stamp = (finalLength: number, date?: Date): string => {\n    const hexStamp = Math.floor(+(date || new Date()) / 1000).toString(16);\n\n    if (typeof finalLength === 'number' && finalLength === 0) {\n      return hexStamp;\n    }\n\n    if (typeof finalLength !== 'number' || finalLength < 10) {\n      throw new Error(\n        [\n          'Param finalLength must be a number greater than or equal to 10,',\n          'or 0 if you want the raw hexadecimal timestamp',\n        ].join('\\n')\n      );\n    }\n\n    const idLength = finalLength - 9;\n\n    const rndIdx = Math.round(Math.random() * ((idLength > 15) ? 15 : idLength));\n\n    const id = this.randomUUID(idLength);\n\n    return `${id.substring(0, rndIdx)}${hexStamp}${id.substring(rndIdx)}${rndIdx.toString(16)}`;\n  };\n\n  /**\n   * Extracts the date embeded in a UUID generated using the `uid.stamp(finalLength);` method.\n   * \n   * ```js\n   *  const uidWithTimestamp = uid.stamp(32);\n   *  console.log(uidWithTimestamp);\n   *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n   * \n   *  console.log(uid.parseStamp(uidWithTimestamp));\n   *  // 2021-05-03T06:24:58.000Z\n   *  ```\n   */\n  parseStamp = (suid: string, format?: string): Date => {\n    if (format && !(/t0|t[1-9]\\d{1,}/).test(format)) {\n      throw new Error('Cannot extract date from a formated UUID with no timestamp in the format');\n    }\n\n    const stamp = (\n      format\n    ) ? (\n      format.replace(\n        /\\$[rs]\\d{0,}|\\$t0|\\$t[1-9]\\d{1,}/g,\n        (m) => {\n          const fnMap = {\n            '$r': (len: number) => [...Array(len)].map(() => 'r').join(''),\n            '$s': (len: number) => [...Array(len)].map(() => 's').join(''),\n            '$t': (len: number) => [...Array(len)].map(() => 't').join(''),\n          };\n\n          const fn = m.slice(0, 2);\n          const len = parseInt(m.slice(2), 10);\n\n          return fnMap[fn as keyof typeof fnMap](len);\n        },\n      ).replace(\n        /^(.*?)(t{8,})(.*)$/g,\n        (_m, p1, p2) => {\n          return suid.substring(p1.length, p1.length + p2.length);\n        },\n      )\n    ) : (\n      suid\n    );\n\n    if (stamp.length === 8) {\n      return new Date(parseInt(stamp, 16) * 1000);\n    }\n\n    if (stamp.length < 10) {\n      throw new Error('Stamp length invalid');\n    }\n\n    const rndIdx = parseInt(stamp.substring(stamp.length - 1), 16);\n\n    return new Date(parseInt(stamp.substring(rndIdx, rndIdx + 8), 16) * 1000);\n  };\n\n  /**\n   * Set the counter to a specific value.\n   */\n  setCounter = (counter: number): void => {\n    this.counter = counter;\n  };\n\n  constructor(argOptions: Partial<ShortUniqueIdOptions> = {}) {\n    const options: ShortUniqueIdOptions = {\n      ...DEFAULT_OPTIONS,\n      ...argOptions as Partial<ShortUniqueIdOptions>,\n    };\n\n    this.counter = 0;\n    this.debug = false;\n    this.dict = [];\n    this.version = version;\n\n    const {\n      dictionary,\n      shuffle,\n      length,\n      counter,\n    } = options;\n\n    this.uuidLength = length;\n\n    this.setDictionary(dictionary, shuffle);\n    this.setCounter(counter);\n\n    this.debug = options.debug;\n    this.log(this.dict);\n    this.log(\n      `Generator instantiated with Dictionary Size ${this.dictLength} and counter set to ${this.counter}`\n    );\n\n    this.log = this.log.bind(this);\n    this.setDictionary = this.setDictionary.bind(this);\n    this.setCounter = this.setCounter.bind(this);\n    this.seq = this.seq.bind(this);\n    this.sequentialUUID = this.sequentialUUID.bind(this);\n    this.rnd = this.rnd.bind(this);\n    this.randomUUID = this.randomUUID.bind(this);\n    this.fmt = this.fmt.bind(this);\n    this.formattedUUID = this.formattedUUID.bind(this);\n    this.availableUUIDs = this.availableUUIDs.bind(this);\n    this.approxMaxBeforeCollision = this.approxMaxBeforeCollision.bind(this);\n    this.collisionProbability = this.collisionProbability.bind(this);\n    this.uniqueness = this.uniqueness.bind(this);\n    this.getVersion = this.getVersion.bind(this);\n    this.stamp = this.stamp.bind(this);\n    this.parseStamp = this.parseStamp.bind(this);\n\n    return this;\n  }\n}\n","{\n  \"name\": \"short-unique-id\",\n  \"version\": \"5.0.3\",\n  \"description\": \"Generate random or sequential UUID of any length\",\n  \"keywords\": [\n    \"short\",\n    \"random\",\n    \"uid\",\n    \"uuid\",\n    \"guid\",\n    \"node\",\n    \"unique id\",\n    \"generator\",\n    \"tiny\"\n  ],\n  \"bin\": {\n    \"short-unique-id\": \"bin/short-unique-id\",\n    \"suid\": \"bin/short-unique-id\"\n  },\n  \"main\": \"dist/short-unique-id.js\",\n  \"types\": \"dist/short-unique-id.d.ts\",\n  \"homepage\": \"https://shortunique.id\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/jeanlescure/short-unique-id\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"runkitExampleFilename\": \"./runkit.js\",\n  \"scripts\": {\n    \"test\": \"ts-node src/test.ts\",\n    \"build\": \"./scripts/build\",\n    \"docs\": \"./scripts/docs\",\n    \"release\": \"release-it\"\n  },\n  \"release-it\": {\n    \"git\": {\n      \"changelog\": \"auto-changelog --stdout -l false -u -t ./assets/changelog-compact.hbs\"\n    },\n    \"hooks\": {\n      \"after:bump\": \"./scripts/release\"\n    },\n    \"npm\": {\n      \"publish\": false\n    }\n  },\n  \"files\": [\n    \"bin\",\n    \"dist\",\n    \"runkit.js\",\n    \"package.json\"\n  ],\n  \"devDependencies\": {\n    \"@types/node\": \"^20.3.2\",\n    \"auto-changelog\": \"^2.4.0\",\n    \"esbuild\": \"^0.18.10\",\n    \"refup\": \"^1.1.0\",\n    \"release-it\": \"^15.11.0\",\n    \"ts-node\": \"^10.9.1\",\n    \"tslib\": \"^2.6.0\",\n    \"typedoc\": \"^0.24.8\",\n    \"typedoc-plugin-extras\": \"^2.3.3\",\n    \"typedoc-plugin-rename-defaults\": \"^0.6.5\",\n    \"typedoc-plugin-script-inject\": \"^1.0.0\",\n    \"typescript\": \"^5.1.6\"\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}